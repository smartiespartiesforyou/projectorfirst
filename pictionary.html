<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pictionary ‚Äî ProjectorFirst</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* Custom Blue Color for Consistency */
    .pf-blue-bg { background: #1e3a8a; } 
    .pf-blue-bg:hover { background: #1d4ed8; } 
    .pf-blue-text { color: #1e3a8a; }

    /* Drawing Board Styles */
    svg { 
        width: 100%; 
        height: auto; 
        display: block;
        margin: 0 auto;
    }
    .unselectable { user-select: none; }
    
    /* Fullscreen Mode Optimization (Hides header/footer in fullscreen) */
    :fullscreen .hide-on-fullscreen {
        display: none !important;
    }
    :fullscreen {
        background-color: white; /* Ensure full screen is white */
    }
  </style>

  <script data-memberstack-app="app_cmgnwpg8y00x10suih4pua785"
          src="https://static.memberstack.com/scripts/v2/memberstack.js"
          type="text/javascript"></script>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      // Safest wait for Memberstack to ensure it's loaded
      const waitForMemberstack = () =>
        new Promise((resolve) => {
          const check = () => {
            if (window.$memberstackDom) resolve(window.$memberstackDom);
            else setTimeout(check, 100);
          };
          check();
        });

      const memberstack = await waitForMemberstack();

      try {
        const { data: member } = await memberstack.getCurrentMember();
        // Redirect if not logged in
        if (!member) {
          window.location.replace("index.html"); // Redirect to home/login
          return;
        }

        // Check for active plan (or trial plan if applicable)
        const hasAccess = Array.isArray(member.planConnections) &&
          member.planConnections.some(plan => plan.status === "ACTIVE" || plan.planId === "pln_trial30-gpte0tfl");

        if (!hasAccess) {
          window.location.replace("checkout.html"); // Redirect if subscription lapsed
          return;
        }
      } catch (e) {
        console.error("Auth check failed:", e);
        window.location.replace("index.html");
      }
    });
  </script>
</head>

<body class="bg-white text-gray-900 min-h-screen unselectable">
  
  <div class="w-full px-4 sm:px-6 lg:px-12 py-6 max-w-7xl mx-auto">
    
    <div class="flex flex-col sm:flex-row justify-between items-center mb-8 hide-on-fullscreen">
        <a href="apps.html"
           class="order-2 sm:order-1 pf-blue-bg text-white px-5 py-3 rounded-xl text-xl font-bold hover:pf-blue-bg transition duration-150 shadow-md">
            ‚Üê Back to Apps
        </a>
        <h1 class="order-1 sm:order-2 text-4xl md:text-5xl font-extrabold pf-blue-text text-center mb-4 sm:mb-0">
            Pictionary üé®
        </h1>
        <div class="order-3 w-28 sm:w-auto"></div> </div>

    <div class="flex justify-center gap-4 flex-wrap mb-8 hide-on-fullscreen">
        
      <button id="startBtn"
              class="flex-1 min-w-[120px] px-6 py-4 bg-green-700 text-white rounded-xl text-xl font-bold hover:bg-green-600 transition duration-150 shadow-md">
          Start
      </button>

      <button id="pauseBtn"
              class="flex-1 min-w-[120px] px-6 py-4 bg-yellow-600 text-white rounded-xl text-xl font-bold hover:bg-yellow-500 transition duration-150 shadow-md" disabled>
          Pause
      </button>

      <button id="nextBtn"
              class="flex-1 min-w-[120px] px-6 py-4 pf-blue-bg text-white rounded-xl text-xl font-bold hover:pf-blue-bg transition duration-150 shadow-md">
          Next
      </button>

      <button id="revealBtn"
              class="flex-1 min-w-[120px] px-6 py-4 bg-purple-700 text-white rounded-xl text-xl font-bold hover:bg-purple-600 transition duration-150 shadow-md">
          Show Answer
      </button>
      
      <button id="fullscreenBtn"
              class="flex-1 min-w-[120px] px-6 py-4 bg-gray-600 text-white rounded-xl text-xl font-bold hover:bg-gray-500 transition duration-150 shadow-md">
          ‚õ∂ Full Screen
      </button>
    </div>

    <div class="text-center mb-6">
        <div id="prompt" class="text-4xl font-bold text-gray-600">
            Click START to begin drawing!
        </div>
        <div id="answer" class="text-5xl font-extrabold pf-blue-text mt-3 opacity-0 transition-opacity duration-300">
            [Answer will appear here]
        </div>
    </div>

    <div id="drawing-container" class="bg-white border-8 pf-blue-bg rounded-2xl shadow-2xl p-4 md:p-6 w-full mx-auto" style="aspect-ratio: 4/3;">
        <svg id="stage" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg"
             aria-label="Animated drawing" role="img"></svg>
    </div>

    <div id="status" class="text-center mt-4 text-xl font-semibold text-gray-700 hide-on-fullscreen">
        Ready.
    </div>
  </div>

  <script>
    // ---------- SETTINGS ----------
    // Bold projector strokes + SLOW, fixed speed
    const strokeStyle = {
      stroke: '#1e3a8a', // Use PF Blue for stroke
      'stroke-width': 18, // Extra bold stroke for projector
      fill: 'none',
      'stroke-linecap': 'round',
      'stroke-linejoin': 'round'
    };
    const PX_PER_SEC = 25; // Super slow for senior viewing/guessing time

    // ---------- HELPERS ----------
    function E(tag, attrs = {}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
      if (!attrs.stroke && tag !== 'g') {
        for (const [k, v] of Object.entries(strokeStyle)) el.setAttribute(k, v);
      }
      return el;
    }
    function setDashForAnimate(el) {
      const len = el.getTotalLength();
      el.style.strokeDasharray = String(len);
      el.style.strokeDashoffset = String(len);
      return len;
    }
    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ---------- DRAWING LIBRARY ----------
    // Simple, high-contrast outlines sized for 800x600 viewBox
    const library = {
      Apple: () => {
        const g = [];
        g.push(E('path', { d: 'M400 200 C340 160 260 210 260 300 C260 380 330 430 400 470 C470 430 540 380 540 300 C540 210 460 160 400 200 Z' }));
        g.push(E('path', { d: 'M400 200 C400 160 410 140 430 120' }));
        g.push(E('path', { d: 'M440 120 C500 110 520 160 460 170 C460 170 450 150 440 120 Z' }));
        return g;
      },
      House: () => {
        const g = [];
        g.push(E('rect', { x: 260, y: 280, width: 280, height: 200, rx: 8, ry: 8 }));
        g.push(E('polygon', { points: '240,280 400,170 560,280' }));
        g.push(E('rect', { x: 370, y: 360, width: 60, height: 120, rx: 6 }));
        g.push(E('rect', { x: 290, y: 320, width: 80, height: 60, rx: 6 }));
        g.push(E('rect', { x: 430, y: 320, width: 80, height: 60, rx: 6 }));
        return g;
      },
      Dog: () => {
        const g = [];
        g.push(E('ellipse', { cx: 320, cy: 300, rx: 70, ry: 55 }));
        g.push(E('path', { d: 'M280 270 C250 250 250 310 280 290' }));
        g.push(E('circle', { cx: 340, cy: 290, r: 8 }));
        g.push(E('circle', { cx: 285, cy: 310, r: 8 }));
        g.push(E('ellipse', { cx: 460, cy: 330, rx: 110, ry: 70 }));
        g.push(E('path', { d: 'M560 330 C600 320 600 360 560 350' }));
        g.push(E('line', { x1: 420, y1: 390, x2: 420, y2: 460 }));
        g.push(E('line', { x1: 500, y1: 390, x2: 500, y2: 460 }));
        return g;
      },
      Flower: () => {
        const g = [];
        g.push(E('line', { x1: 400, y1: 260, x2: 400, y2: 460 }));
        g.push(E('path', { d: 'M400 340 C360 330 340 350 350 370 C360 350 380 350 400 350' }));
        g.push(E('path', { d: 'M400 380 C440 370 460 390 450 410 C440 390 420 390 400 390' }));
        g.push(E('circle', { cx: 400, cy: 220, r: 28 }));
        g.push(E('circle', { cx: 400, cy: 180, r: 24 }));
        g.push(E('circle', { cx: 440, cy: 200, r: 24 }));
        g.push(E('circle', { cx: 360, cy: 200, r: 24 }));
        g.push(E('circle', { cx: 380, cy: 245, r: 24 }));
        g.push(E('circle', { cx: 420, cy: 245, r: 24 }));
        return g;
      },
      Car: () => {
        const g = [];
        g.push(E('path', { d: 'M230 360 L250 320 C270 300 320 280 420 280 L520 280 C550 280 560 300 570 320 L590 360 Z' }));
        g.push(E('line', { x1: 230, y1: 360, x2: 590, y2: 360 }));
        g.push(E('rect', { x: 360, y: 295, width: 90, height: 40, rx: 6 }));
        g.push(E('rect', { x: 460, y: 295, width: 70, height: 40, rx: 6 }));
        g.push(E('circle', { cx: 300, cy: 360, r: 36 }));
        g.push(E('circle', { cx: 520, cy: 360, r: 36 }));
        return g;
      },
      Tree: () => {
        const g = [];
        g.push(E('rect', { x: 385, y: 340, width: 30, height: 130, rx: 4 }));
        g.push(E('circle', { cx: 360, cy: 280, r: 65 }));
        g.push(E('circle', { cx: 440, cy: 280, r: 65 }));
        g.push(E('circle', { cx: 400, cy: 230, r: 70 }));
        return g;
      },
      Fish: () => {
        const g = [];
        g.push(E('ellipse', { cx: 400, cy: 320, rx: 125, ry: 65 }));
        g.push(E('polygon', { points: '525,320 590,290 590,350' }));
        g.push(E('circle', { cx: 350, cy: 305, r: 8 }));
        g.push(E('path', { d: 'M420 280 C410 260 460 260 450 285' }));
        return g;
      },
      IceCream: () => {
        const g = [];
        // redrawn, cleaner cone + scoops
        g.push(E('polygon', { points: '400,420 350,520 450,520' }));
        g.push(E('circle', { cx: 380, cy: 380, r: 44 }));
        g.push(E('circle', { cx: 420, cy: 380, r: 44 }));
        g.push(E('circle', { cx: 400, cy: 345, r: 40 }));
        g.push(E('path', { d: 'M420 420 C415 445 395 445 390 420' }));
        return g;
      },
      Sun: () => {
        const g = [];
        g.push(E('circle', { cx: 400, cy: 300, r: 80 }));
        [[400,190,400,110],[400,410,400,490],[290,300,210,300],[510,300,590,300],
          [330,230,270,170],[470,230,530,170],[330,370,270,430],[470,370,530,430]]
          .forEach(([x1,y1,x2,y2]) => g.push(E('line', { x1,y1,x2,y2 })));
        return g;
      },
      Boat: () => {
        const g = [];
        g.push(E('path', { d: 'M250 380 C300 440 500 440 550 380 L250 380 Z' }));
        g.push(E('line', { x1: 400, y1: 380, x2: 400, y2: 210 }));
        g.push(E('polygon', { points: '400,210 520,300 400,300' }));
        g.push(E('path', { d: 'M400 210 C420 220 430 205 455 210' }));
        return g;
      },
      Book: () => {
        const g = [];
        g.push(E('path', { d: 'M220 240 C300 210 380 230 400 260 C420 230 500 210 580 240 L580 420 C500 390 420 410 400 440 C380 410 300 390 220 420 Z' }));
        g.push(E('path', { d: 'M400 260 L400 440' }));
        g.push(E('path', { d: 'M360 290 C330 280 290 285 250 300' }));
        g.push(E('path', { d: 'M360 330 C330 320 290 325 250 340' }));
        g.push(E('path', { d: 'M440 290 C470 280 510 285 550 300' }));
        g.push(E('path', { d: 'M440 330 C470 320 510 325 550 340' }));
        return g;
      },

      // ---- Custom Uploads ----
      Key: () => {
        const g = [];
        // Approximated vectorization of your key outline (bold)
        g.push(E('ellipse', { cx: 340, cy: 210, rx: 60, ry: 45 }));
        g.push(E('ellipse', { cx: 320, cy: 230, rx: 45, ry: 35 }));
        g.push(E('path', { d: 'M320 260 L320 470 L360 470 L360 440 L380 440 L380 410 L400 410 L400 380 L430 380 L430 330' }));
        g.push(E('path', { d: 'M290 250 C270 220 360 190 380 240 C390 270 340 280 320 260 Z' }));
        g.push(E('path', { d: 'M395 235 C445 260 480 220 520 250' }));
        g.push(E('polygon', { points: '520,250 570,280 560,220' }));
        return g;
      },
      Microwave: () => {
        const g = [];
        g.push(E('rect', { x: 220, y: 200, width: 360, height: 220, rx: 6 }));
        g.push(E('rect', { x: 250, y: 230, width: 250, height: 170, rx: 4 }));
        g.push(E('path', { d: 'M485 255 C500 255 500 375 485 375' }));
        g.push(E('circle', { cx: 540, cy: 260, r: 18 }));
        g.push(E('circle', { cx: 540, cy: 310, r: 14 }));
        g.push(E('circle', { cx: 540, cy: 360, r: 18 }));
        g.push(E('rect', { x: 260, y: 420, width: 40, height: 15, rx: 6 }));
        g.push(E('rect', { x: 480, y: 420, width: 40, height: 15, rx: 6 }));
        return g;
      }
    };

    // ---------- RUNTIME ----------
    const itemNames = Object.keys(library);
    let order = shuffle([...itemNames]);
    let current = 0;

    const stage = document.getElementById('stage');
    const prompt = document.getElementById('prompt');
    const answer = document.getElementById('answer');
    const status = document.getElementById('status');
    const drawingContainer = document.getElementById('drawing-container');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const nextBtn  = document.getElementById('nextBtn');
    const revealBtn= document.getElementById('revealBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    let animQueue = [];    // [{el, len, remaining}]
    let rafId = null;
    let paused = false;
    let isAnimating = false;

    function loadDrawing(name) {
      stage.innerHTML = '';
      prompt.textContent = 'Now Drawing: ' + (current + 1) + ' of ' + order.length;
      answer.textContent = name.toUpperCase();
      answer.style.opacity = 0;
      status.textContent = 'Press START to draw!';
      animQueue = [];
      isAnimating = false;
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'Pause';

      const strokes = library[name]();
      const group = E('g', {});
      stage.appendChild(group);

      strokes.forEach(el => {
        group.appendChild(el);
        const len = setDashForAnimate(el);
        animQueue.push({ el, len, remaining: len });
      });

      cancelAnimationFrame(rafId);
    }

    function startAnimation() {
      if (isAnimating) return;
      if (!animQueue.length) {
         status.textContent = 'All drawings done!';
         return;
      }

      isAnimating = true;
      pauseBtn.disabled = false;
      let last = performance.now();

      function step(now) {
        if (paused) { rafId = requestAnimationFrame(step); return; }
        
        const dt = (now - last) / 1000;
        last = now;
        const advance = PX_PER_SEC * dt;

        let finishedAllStrokes = true;
        
        // Find the current active stroke (the one with remaining > 0)
        let activeStroke = animQueue.find(seg => seg.remaining > 0);

        if (activeStroke) {
            finishedAllStrokes = false;
            activeStroke.remaining = Math.max(0, activeStroke.remaining - advance);
            activeStroke.el.style.strokeDashoffset = String(activeStroke.remaining);
            status.textContent = 'Drawing... (Guess the word!)';
        } else {
            // Check if all are actually finished
            finishedAllStrokes = animQueue.every(seg => seg.remaining <= 0);
        }

        if (finishedAllStrokes) {
          status.textContent = 'Done! Press SHOW ANSWER.';
          isAnimating = false;
          pauseBtn.disabled = true;
          cancelAnimationFrame(rafId);
          return;
        }
        rafId = requestAnimationFrame(step);
      }
      rafId = requestAnimationFrame(step);
    }

    // Controls
    startBtn.addEventListener('click', () => {
      // If already started and paused, resume. Otherwise, load new.
      if (paused) {
        paused = false;
        pauseBtn.textContent = 'Pause';
        startAnimation();
      } else {
        loadDrawing(order[current]);
        startAnimation();
      }
    });
    
    pauseBtn.addEventListener('click', () => {
      if (pauseBtn.disabled) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if (!paused) startAnimation(); // Resume animation if unpausing
    });
    
    nextBtn.addEventListener('click', () => {
      current = (current + 1) % order.length;
      loadDrawing(order[current]);
      // Immediately start the next one
      startAnimation(); 
    });
    
    revealBtn.addEventListener('click', () => { 
        answer.style.opacity = 1; 
        status.textContent = 'ANSWER REVEALED!';
    });

    // Fullscreen
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        fullscreenBtn.textContent = "Exit Full Screen";
        // Maximize SVG within container in fullscreen mode
        drawingContainer.style.maxWidth = '100vw'; 
        drawingContainer.style.maxHeight = '100vh';
      } else {
        document.exitFullscreen();
        fullscreenBtn.textContent = "‚õ∂ Full Screen";
        // Restore normal max-width on exit
        drawingContainer.style.maxWidth = '';
        drawingContainer.style.maxHeight = '';
      }
    });
    
    // Handle fullscreen exit via ESC key
    document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement) {
            fullscreenBtn.textContent = "‚õ∂ Full Screen";
            drawingContainer.style.maxWidth = '';
            drawingContainer.style.maxHeight = '';
        }
    });

    // Init first drawing
    loadDrawing(order[current]);
  </script>
</body>
</html>
