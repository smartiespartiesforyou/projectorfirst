<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pictionary — ProjectorFirst</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Memberstack Gate -->
  <script data-memberstack-app="app_cmgnwpg8y00x10suih4pua785"
          src="https://static.memberstack.com/scripts/v2/memberstack.js"
          type="text/javascript"></script>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      try {
        const member = await window.$memberstackDom.getCurrentMember();
        if (!member.data) window.location.href = "/subscribe.html";
      } catch {
        window.location.href = "/subscribe.html";
      }
    });
  </script>

  <style>
    svg { width: 100%; height: auto; }
    .unselectable { user-select: none; }
  </style>
</head>

<body class="bg-white text-gray-900 min-h-screen unselectable">
  <div class="w-full px-2 sm:px-6 lg:px-12 py-6 max-w-7xl mx-auto">
    <!-- Title -->
    <h1 class="text-6xl font-extrabold mb-4 text-blue-900 text-center">Pictionary</h1>

    <!-- Controls -->
    <div class="flex justify-center gap-4 flex-wrap mb-6">
      <a href="apps.html"
         class="px-8 py-4 bg-blue-900 text-white rounded-2xl text-2xl font-bold hover:bg-blue-800">← Apps</a>

      <button id="fullscreenBtn"
              class="px-8 py-4 bg-blue-700 text-white rounded-2xl text-2xl font-bold hover:bg-blue-800">⛶ Full Screen</button>

      <button id="startBtn"
              class="px-8 py-4 bg-green-700 text-white rounded-2xl text-2xl font-bold hover:bg-green-800">Start</button>

      <button id="pauseBtn"
              class="px-8 py-4 bg-yellow-500 text-white rounded-2xl text-2xl font-bold hover:bg-yellow-600" disabled>Pause</button>

      <button id="nextBtn"
              class="px-8 py-4 bg-blue-600 text-white rounded-2xl text-2xl font-bold hover:bg-blue-700">Next</button>

      <button id="revealBtn"
              class="px-8 py-4 bg-purple-700 text-white rounded-2xl text-2xl font-bold hover:bg-purple-800">Show Answer</button>
    </div>

    <!-- Prompt / Answer -->
    <div class="text-center mb-3">
      <div id="prompt" class="text-3xl font-bold text-gray-600">Mystery Drawing…</div>
      <div id="answer" class="text-4xl font-extrabold text-blue-900 mt-1 opacity-0 transition-opacity">Answer</div>
    </div>

    <!-- Drawing Area -->
    <div class="bg-white border-8 border-blue-900 rounded-2xl shadow-2xl p-4">
      <div class="mx-auto" style="max-width: 1100px;">
        <svg id="stage" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg"
             aria-label="Animated drawing" role="img"></svg>
      </div>
    </div>

    <!-- Status -->
    <div id="status" class="text-center mt-4 text-2xl font-semibold text-blue-700"></div>
  </div>

  <script>
    // ---------- SETTINGS ----------
    // Bold projector strokes + steady pace
    const strokeStyle = {
      stroke: '#1e3a8a',
      'stroke-width': 14,
      fill: 'none',
      'stroke-linecap': 'round',
      'stroke-linejoin': 'round'
    };
    const PX_PER_SEC = 300; // fixed animation speed (no slider)

    // ---------- HELPERS ----------
    function E(tag, attrs = {}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
      if (!attrs.stroke && tag !== 'g') {
        for (const [k, v] of Object.entries(strokeStyle)) el.setAttribute(k, v);
      }
      return el;
    }
    function setDashForAnimate(el) {
      const len = el.getTotalLength();
      el.style.strokeDasharray = String(len);
      el.style.strokeDashoffset = String(len);
      return len;
    }
    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // ---------- DRAWING LIBRARY ----------
    // Simple, high-contrast outlines sized for 800x600 viewBox
    const library = {
      Apple: () => {
        const g = [];
        g.push(E('path', { d: 'M400 200 C340 160 260 210 260 300 C260 380 330 430 400 470 C470 430 540 380 540 300 C540 210 460 160 400 200 Z' }));
        g.push(E('path', { d: 'M400 200 C400 160 410 140 430 120' }));
        g.push(E('path', { d: 'M440 120 C500 110 520 160 460 170 C460 170 450 150 440 120 Z' }));
        return g;
      },
      House: () => {
        const g = [];
        g.push(E('rect', { x: 260, y: 280, width: 280, height: 200, rx: 8, ry: 8 }));
        g.push(E('polygon', { points: '240,280 400,170 560,280' }));
        g.push(E('rect', { x: 370, y: 360, width: 60, height: 120, rx: 6 }));
        g.push(E('rect', { x: 290, y: 320, width: 80, height: 60, rx: 6 }));
        g.push(E('rect', { x: 430, y: 320, width: 80, height: 60, rx: 6 }));
        return g;
      },
      Dog: () => {
        const g = [];
        g.push(E('ellipse', { cx: 320, cy: 300, rx: 70, ry: 55 }));
        g.push(E('path', { d: 'M280 270 C250 250 250 310 280 290' }));
        g.push(E('circle', { cx: 340, cy: 290, r: 8 }));
        g.push(E('circle', { cx: 285, cy: 310, r: 8 }));
        g.push(E('ellipse', { cx: 460, cy: 330, rx: 110, ry: 70 }));
        g.push(E('path', { d: 'M560 330 C600 320 600 360 560 350' }));
        g.push(E('line', { x1: 420, y1: 390, x2: 420, y2: 460 }));
        g.push(E('line', { x1: 500, y1: 390, x2: 500, y2: 460 }));
        return g;
      },
      Flower: () => {
        const g = [];
        g.push(E('line', { x1: 400, y1: 260, x2: 400, y2: 460 }));
        g.push(E('path', { d: 'M400 340 C360 330 340 350 350 370 C360 350 380 350 400 350' }));
        g.push(E('path', { d: 'M400 380 C440 370 460 390 450 410 C440 390 420 390 400 390' }));
        g.push(E('circle', { cx: 400, cy: 220, r: 28 }));
        g.push(E('circle', { cx: 400, cy: 180, r: 24 }));
        g.push(E('circle', { cx: 440, cy: 200, r: 24 }));
        g.push(E('circle', { cx: 360, cy: 200, r: 24 }));
        g.push(E('circle', { cx: 380, cy: 245, r: 24 }));
        g.push(E('circle', { cx: 420, cy: 245, r: 24 }));
        return g;
      },
      Car: () => {
        const g = [];
        g.push(E('path', { d: 'M230 360 L250 320 C270 300 320 280 420 280 L520 280 C550 280 560 300 570 320 L590 360 Z' }));
        g.push(E('line', { x1: 230, y1: 360, x2: 590, y2: 360 }));
        g.push(E('rect', { x: 360, y: 295, width: 90, height: 40, rx: 6 }));
        g.push(E('rect', { x: 460, y: 295, width: 70, height: 40, rx: 6 }));
        g.push(E('circle', { cx: 300, cy: 360, r: 36 }));
        g.push(E('circle', { cx: 520, cy: 360, r: 36 }));
        return g;
      },
      Tree: () => {
        const g = [];
        g.push(E('rect', { x: 385, y: 340, width: 30, height: 130, rx: 4 }));
        g.push(E('circle', { cx: 360, cy: 280, r: 65 }));
        g.push(E('circle', { cx: 440, cy: 280, r: 65 }));
        g.push(E('circle', { cx: 400, cy: 230, r: 70 }));
        return g;
      },
      Fish: () => {
        const g = [];
        g.push(E('ellipse', { cx: 400, cy: 320, rx: 125, ry: 65 }));
        g.push(E('polygon', { points: '525,320 590,290 590,350' }));
        g.push(E('circle', { cx: 350, cy: 305, r: 8 }));
        g.push(E('path', { d: 'M420 280 C410 260 460 260 450 285' }));
        return g;
      },
      IceCream: () => {
        const g = [];
        g.push(E('polygon', { points: '400,420 350,520 450,520' }));
        g.push(E('circle', { cx: 380, cy: 380, r: 44 }));
        g.push(E('circle', { cx: 420, cy: 380, r: 44 }));
        g.push(E('circle', { cx: 400, cy: 345, r: 40 }));
        g.push(E('path', { d: 'M420 420 C415 445 395 445 390 420' }));
        return g;
      },
      Sun: () => {
        const g = [];
        g.push(E('circle', { cx: 400, cy: 300, r: 80 }));
        [[400,190,400,110],[400,410,400,490],[290,300,210,300],[510,300,590,300],
         [330,230,270,170],[470,230,530,170],[330,370,270,430],[470,370,530,430]]
         .forEach(([x1,y1,x2,y2]) => g.push(E('line', { x1,y1,x2,y2 })));
        return g;
      },
      Boat: () => {
        const g = [];
        g.push(E('path', { d: 'M250 380 C300 440 500 440 550 380 L250 380 Z' }));
        g.push(E('line', { x1: 400, y1: 380, x2: 400, y2: 210 }));
        g.push(E('polygon', { points: '400,210 520,300 400,300' }));
        g.push(E('path', { d: 'M400 210 C420 220 430 205 455 210' }));
        return g;
      },
      // ---- Custom items (bold strokes) ----
      Key: () => {
        const g = [];
        // key ring + inner ring
        g.push(E('ellipse', { cx: 340, cy: 210, rx: 60, ry: 45 }));
        g.push(E('ellipse', { cx: 320, cy: 230, rx: 45, ry: 35 }));
        // shank + teeth
        g.push(E('path', { d: 'M320 260 L320 470 L360 470 L360 440 L380 440 L380 410 L400 410 L400 380 L430 380 L430 330' }));
        // head inner contour
        g.push(E('path', { d: 'M290 250 C270 220 360 190 380 240 C390 270 340 280 320 260 Z' }));
        // tag + string (simple)
        g.push(E('path', { d: 'M395 235 C445 260 480 220 520 250' }));
        g.push(E('polygon', { points: '520,250 570,280 560,220' }));
        g.push(E('path', { d: 'M550 255 L565 270' })); // tiny heart hint (just a notch)
        return g;
      },
      Microwave: () => {
        const g = [];
        // outer box
        g.push(E('rect', { x: 220, y: 200, width: 360, height: 220, rx: 6 }));
        // door frame
        g.push(E('rect', { x: 250, y: 230, width: 250, height: 170, rx: 4 }));
        // handle
        g.push(E('path', { d: 'M485 255 C500 255 500 375 485 375' }));
        // control buttons
        g.push(E('circle', { cx: 540, cy: 260, r: 18 }));
        g.push(E('circle', { cx: 540, cy: 310, r: 14 }));
        g.push(E('circle', { cx: 540, cy: 360, r: 18 }));
        // feet
        g.push(E('rect', { x: 260, y: 420, width: 40, height: 15, rx: 6 }));
        g.push(E('rect', { x: 480, y: 420, width: 40, height: 15, rx: 6 }));
        return g;
      },
      Book: () => {
        const g = [];
        // open book outline
        g.push(E('path', { d: 'M220 240 C300 210 380 230 400 260 C420 230 500 210 580 240 L580 420 C500 390 420 410 400 440 C380 410 300 390 220 420 Z' }));
        // center spine
        g.push(E('path', { d: 'M400 260 L400 440' }));
        // page lines (left)
        g.push(E('path', { d: 'M360 290 C330 280 290 285 250 300' }));
        g.push(E('path', { d: 'M360 330 C330 320 290 325 250 340' }));
        // page lines (right)
        g.push(E('path', { d: 'M440 290 C470 280 510 285 550 300' }));
        g.push(E('path', { d: 'M440 330 C470 320 510 325 550 340' }));
        return g;
      }
    };

    // ---------- RUNTIME ----------
    const itemNames = Object.keys(library);  // includes custom items
    let order = shuffle([...itemNames]);
    let current = 0;

    const stage = document.getElementById('stage');
    const answer = document.getElementById('answer');
    const status = document.getElementById('status');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const nextBtn  = document.getElementById('nextBtn');
    const revealBtn= document.getElementById('revealBtn');

    let animQueue = [];   // [{el, len, remaining}]
    let rafId = null;
    let paused = false;

    function loadDrawing(name) {
      stage.innerHTML = '';
      answer.textContent = name;
      answer.style.opacity = 0;
      status.textContent = '';
      animQueue = [];

      const strokes = library[name]();
      const group = E('g', {});
      stage.appendChild(group);

      strokes.forEach(el => {
        group.appendChild(el);
        const len = setDashForAnimate(el);
        animQueue.push({ el, len, remaining: len });
      });

      cancelAnimationFrame(rafId);
      paused = false;
      pauseBtn.textContent = 'Pause';
      pauseBtn.disabled = true; // until Start
    }

    function startAnimation() {
      if (!animQueue.length) return;
      pauseBtn.disabled = false;
      let last = performance.now();

      function step(now) {
        if (paused) { rafId = requestAnimationFrame(step); return; }
        const dt = (now - last) / 1000;
        last = now;
        const advance = PX_PER_SEC * dt;

        let finishedAll = true;

        for (const seg of animQueue) {
          if (seg.remaining <= 0) continue;
          finishedAll = false;

          seg.remaining = Math.max(0, seg.remaining - advance);
          seg.el.style.strokeDashoffset = String(seg.remaining);

          if (seg.remaining > 0) break; // keep strokes sequential
        }

        if (finishedAll) {
          status.textContent = 'Done!';
          pauseBtn.disabled = true;
          cancelAnimationFrame(rafId);
          return;
        }
        rafId = requestAnimationFrame(step);
      }
      rafId = requestAnimationFrame(step);
    }

    // Controls
    startBtn.addEventListener('click', () => {
      loadDrawing(order[current]);
      startAnimation();
    });
    pauseBtn.addEventListener('click', () => {
      if (pauseBtn.disabled) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    });
    nextBtn.addEventListener('click', () => {
      current = (current + 1) % order.length;
      loadDrawing(order[current]);
      startAnimation();
    });
    revealBtn.addEventListener('click', () => { answer.style.opacity = 1; });

    // Fullscreen
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
        fullscreenBtn.textContent = "Exit Full Screen";
      } else {
        document.exitFullscreen();
        fullscreenBtn.textContent = "⛶ Full Screen";
      }
    });

    // Init first drawing
    loadDrawing(order[current]);
  </script>
</body>
</html>
