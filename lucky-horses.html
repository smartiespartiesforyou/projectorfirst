<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üêé Lucky Horses ‚Äî ProjectorFirst</title>
  <meta name="description" content="Candy Land‚Äìstyle horse race. Roll 0‚Äì6 (0 = Go Back Home). Specials: Jump Ahead, Go Back, Roll Again, Lose Turn."/>
  <meta name="theme-color" content="#1e3a8a"/>
  <link rel="icon" href="/logo.svg" type="image/svg+xml"/>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root{
      --gap: 10px;
    }
    body{
      background:#fff; color:#111;
      font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
      display:flex; flex-direction:column; align-items:center; min-height:100vh;
      padding:1.25rem; text-align:center;
    }
    h1{ font-size:3.2rem; font-weight:900; color:#1e3a8a; margin:.4rem 0 .2rem }
    .sub{ font-size:1.25rem; color:#374151 }

    /* Board fills the screen width */
    #board{ width:min(98vw, 1900px); margin:1rem auto 0 }

    /* Lane colors (ProjectorFirst palette tints) */
    .laneWrap{ margin:16px 0; }
    .laneHdr{ display:flex; align-items:center; gap:12px; margin:0 0 8px 6px; font-weight:900; color:#1e3a8a; font-size:1.3rem }
    .pill{ border-radius:999px; color:#fff; padding:4px 12px; font-weight:800 }
    .p1{ background:#1e3a8a } .p2{ background:#dc2626 } .p3{ background:#16a34a } .p4{ background:#7c3aed }

    .lane{
      position:relative; padding:10px 12px 18px;
      border-radius:16px; box-shadow: 0 6px 0 #1e3a8a22;
      border:3px solid #1e3a8a22; background:#ffffff;
    }

    /* Full-width grid: exactly TRACK_LEN columns, squares keep aspect ratio */
    .track{
      --cols: 30;
      display:grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: var(--gap);
      width:100%;
    }
    .sq{
      aspect-ratio:1/1;
      border-radius:12px;
      display:flex; align-items:center; justify-content:center;
      position:relative; font-size:clamp(20px, 2.6vw, 36px); font-weight:800;
      user-select:none;
    }

    /* Per-lane alternating tints + borders */
    .lane1 .sq{ border:3px solid #93c5fd }
    .lane1 .sq:nth-child(odd){ background:#dbeafe }
    .lane1 .sq:nth-child(even){ background:#bfdbfe }

    .lane2 .sq{ border:3px solid #fca5a5 }
    .lane2 .sq:nth-child(odd){ background:#fee2e2 }
    .lane2 .sq:nth-child(even){ background:#fecaca }

    .lane3 .sq{ border:3px solid #86efac }
    .lane3 .sq:nth-child(odd){ background:#dcfce7 }
    .lane3 .sq:nth-child(even){ background:#bbf7d0 }

    .lane4 .sq{ border:3px solid #c4b5fd }
    .lane4 .sq:nth-child(odd){ background:#ede9fe }
    .lane4 .sq:nth-child(even){ background:#ddd6fe }

    .start{ outline:4px dashed #1e3a8a; outline-offset:-6px }
    .finish{ outline:4px solid #16a34a; outline-offset:-6px }

    .mark{ position:absolute; right:6px; bottom:4px; font-size:clamp(16px,2vw,24px)}
    .colIndex{ position:absolute; top:4px; left:6px; font-size:.9rem; opacity:.35; font-weight:800 }

    /* Horse token (big + faces RIGHT) */
    .horse{
      position:absolute; font-size:clamp(38px, 4vw, 64px); line-height:1;
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.15));
      display:flex; align-items:center;
      pointer-events:none;
      transition: left .18s ease, top .18s ease;
    }
    .icon{ display:inline-block; transform: scaleX(-1); } /* flip to face right */
    .gallop{ animation: gallop .18s ease-in-out infinite alternate }
    @keyframes gallop{ from{ transform: translateY(0) } to{ transform: translateY(-6px) } }

    /* Buttons + status */
    .btn{ font-size:2rem; font-weight:900; padding:1rem 2rem; border-radius:1rem; min-width:260px; cursor:pointer; transition:transform .08s }
    .btn:hover{ transform:scale(1.04) }
    .btn-blue{ background:#1e3a8a; color:#fff }
    .btn-red{ background:#dc2626; color:#fff }

    #status{ margin-top:.9rem; font-size:2.2rem; color:#1e3a8a; font-weight:900 }
    #winner{ margin-top:.4rem; font-size:2.4rem; font-weight:900; color:#16a34a }

    .legend{ display:flex; gap:16px; justify-content:center; flex-wrap:wrap; margin:10px 0; color:#374151 }
    .tag{ display:inline-flex; align-items:center; gap:8px; border:2px solid #cbd5e1; border-radius:999px; padding:6px 12px; font-weight:800; font-size:1rem }
  </style>
</head>
<body>
  <a href="apps.html" class="text-white bg-blue-800 hover:bg-blue-900 px-6 py-3 rounded-full text-2xl font-bold mb-4">‚¨Ö Back to Apps</a>

  <h1>üêé Lucky Horses</h1>
  <p class="sub">Roll the dice (0‚Äì6). <strong>0 = Go Back Home.</strong> Land on ‚≠ê to jump ahead, üíÄ to go back, üîÅ to roll again, üö´ to lose next turn.</p>

  <div id="board"></div>

  <div class="flex flex-wrap gap-5 justify-center mt-5">
    <button id="rollBtn" class="btn btn-blue">üé≤ Roll Dice</button>
    <button id="resetBtn" class="btn btn-red">üîÅ Reset</button>
  </div>

  <div id="status"></div>
  <div id="winner"></div>

  <div class="legend">
    <span class="tag">‚≠ê Jump +3</span>
    <span class="tag">üíÄ Back ‚àí3</span>
    <span class="tag">üîÅ Roll Again</span>
    <span class="tag">üö´ Lose Next Turn</span>
    <span class="tag">üèÅ Finish</span>
  </div>

  <script>
    // ===== CONFIG =====
    const HORSES = ["üêé","üê¥","üêé","üê¥"]; // no unicorns
    const NAMES  = ["Horse 1","Horse 2","Horse 3","Horse 4"];
    const PILLS  = ["p1","p2","p3","p4"];
    const LANE_COUNT = 4;
    const TRACK_LEN  = 30;

    const SPECIAL_COUNTS = { jump:4, back:4, again:2, skip:2 }; // shared positions across lanes
    const JUMP_VALUE = 3;
    const BACK_VALUE = 3;

    // ===== STATE =====
    let lanes = [];           // lane containers
    let trackDivs = [];       // per-lane track grid
    let positions = new Array(LANE_COUNT).fill(0);
    let horseElems = [];
    let skipNext = new Array(LANE_COUNT).fill(false);
    let specials = [];        // array length TRACK_LEN with tile type or null
    let current = 0;
    let finished = false;

    const board  = document.getElementById("board");
    const status = document.getElementById("status");
    const winner = document.getElementById("winner");
    const rollBtn= document.getElementById("rollBtn");
    const resetBtn= document.getElementById("resetBtn");

    // ===== UTIL =====
    const wait = (ms)=>new Promise(r=>setTimeout(r,ms));
    const randInt = (n)=>Math.floor(Math.random()*n);
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=randInt(i+1); [a[i],a[j]]=[a[j],a[i]] } return a; }

    function cryptoRoll(maxExclusive){
      if(window.crypto?.getRandomValues){
        const u = new Uint32Array(1); crypto.getRandomValues(u);
        return u[0] % maxExclusive;
      }
      return randInt(maxExclusive);
    }

    // ===== BUILD =====
    function makeSpecials(){
      const types = [];
      for(let i=0;i<SPECIAL_COUNTS.jump;i++) types.push("jump");
      for(let i=0;i<SPECIAL_COUNTS.back;i++) types.push("back");
      for(let i=0;i<SPECIAL_COUNTS.again;i++) types.push("again");
      for(let i=0;i<SPECIAL_COUNTS.skip;i++) types.push("skip");
      const order = shuffle([...Array(TRACK_LEN-2).keys()].map(i=>i+1)); // avoid 0 & last
      const map = new Array(TRACK_LEN).fill(null);
      for(let k=0;k<types.length && k<order.length;k++) map[order[k]] = types[k];
      map[TRACK_LEN-1] = "finish";
      return map;
    }

    function buildBoard(){
      board.innerHTML = "";
      specials = makeSpecials();
      lanes.length = 0; trackDivs.length = 0; horseElems.length = 0;

      for(let ln=0; ln<LANE_COUNT; ln++){
        const wrap = document.createElement("div");
        wrap.className = "laneWrap";

        const hdr = document.createElement("div");
        hdr.className = "laneHdr";
        hdr.innerHTML = `<span class="pill ${PILLS[ln]}">${NAMES[ln]}</span>`;
        wrap.appendChild(hdr);

        const lane = document.createElement("section");
        lane.className = `lane lane${ln+1}`;
        wrap.appendChild(lane);

        const track = document.createElement("div");
        track.className = "track";
        track.style.setProperty("--cols", TRACK_LEN);
        lane.appendChild(track);

        // build squares
        for(let i=0; i<TRACK_LEN; i++){
          const sq = document.createElement("div");
          sq.className = "sq";
          if(i===0) sq.classList.add("start");
          if(i===TRACK_LEN-1) sq.classList.add("finish");

          // column index (faint)
          const idx = document.createElement("div");
          idx.className = "colIndex";
          idx.textContent = i;
          sq.appendChild(idx);

          const t = specials[i];
          if(t){
            const mark = document.createElement("div");
            mark.className = "mark";
            mark.textContent = t==="jump"?"‚≠ê":t==="back"?"üíÄ":t==="again"?"üîÅ":t==="skip"?"üö´":"";
            sq.appendChild(mark);
          }
          track.appendChild(sq);
        }

        // horse token
        const token = document.createElement("div");
        token.className = "horse";
        token.innerHTML = `<span class="icon">${HORSES[ln]}</span>`;
        lane.appendChild(token);

        board.appendChild(wrap);
        lanes.push(lane);
        trackDivs.push(track);
        horseElems.push(token);
      }

      // initial placement
      for(let ln=0; ln<LANE_COUNT; ln++){
        placeHorse(ln, positions[ln]);
      }
      showTurn();
    }

    // compute token position over a square (lane-local)
    function placeHorse(ln, idx){
      const track = trackDivs[ln];
      const sq = track.children[Math.max(0, Math.min(idx, TRACK_LEN-1))];
      const trackRect = track.getBoundingClientRect();
      const srect = sq.getBoundingClientRect();
      const token = horseElems[ln];
      const left = (srect.left - trackRect.left) + srect.width/2 - (parseFloat(getComputedStyle(token).fontSize) * 0.45);
      const top  = (srect.top  - trackRect.top ) + srect.height/2 - (parseFloat(getComputedStyle(token).fontSize) * 0.55);
      token.style.left = left + "px";
      token.style.top  = top  + "px";
    }

    async function stepMove(ln, steps){
      const dir = Math.sign(steps);
      const count = Math.abs(steps);
      const token = horseElems[ln];
      token.classList.add("gallop");
      for(let s=0; s<count; s++){
        positions[ln] += dir;
        if(positions[ln] < 0) positions[ln] = 0;
        if(positions[ln] > TRACK_LEN-1) positions[ln] = TRACK_LEN-1;
        placeHorse(ln, positions[ln]);
        await wait(190);
      }
      token.classList.remove("gallop");
    }

    function rollD7(){ // 0..6
      return cryptoRoll(7);
    }

    function showTurn(msg){
      if(finished) return;
      status.textContent = msg || `Your turn: ${NAMES[current]} ‚Äî click ‚ÄúRoll Dice‚Äù`;
    }

    async function handleSpecial(ln){
      const tile = specials[positions[ln]];
      if(!tile || tile==="finish") return;

      if(tile==="jump"){
        status.textContent = `‚≠ê ${NAMES[ln]} jumps ahead +${JUMP_VALUE}!`;
        await stepMove(ln, +JUMP_VALUE);
      } else if(tile==="back"){
        status.textContent = `üíÄ ${NAMES[ln]} goes back ‚àí${BACK_VALUE}.`;
        await stepMove(ln, -BACK_VALUE);
      } else if(tile==="again"){
        status.textContent = `üîÅ ${NAMES[ln]} rolls again!`;
        await wait(450);
        await takeTurn(ln, /*forceSame=*/true);
      } else if(tile==="skip"){
        status.textContent = `üö´ ${NAMES[ln]} will lose next turn.`;
        skipNext[ln] = true;
      }
    }

    async function takeTurn(ln, forceSame=false){
      if(finished) return;

      // skip turn?
      if(skipNext[ln]){
        skipNext[ln] = false;
        status.textContent = `üö´ ${NAMES[ln]} skips this turn.`;
        await wait(700);
        if(!forceSame){ current = (current+1)%LANE_COUNT; showTurn(); }
        return;
      }

      // roll
      const roll = rollD7(); // 0..6 (0 = home)
      if(roll===0){
        status.textContent = `üé≤ ${NAMES[ln]} rolled 0 ‚Äî Go Back Home!`;
        await stepMove(ln, -positions[ln]);
      } else {
        status.textContent = `üé≤ ${NAMES[ln]} rolled a ${roll}.`;
        await stepMove(ln, roll);
      }

      // win?
      if(positions[ln] >= TRACK_LEN-1){
        positions[ln] = TRACK_LEN-1;
        placeHorse(ln, positions[ln]);
        winner.textContent = `üèÜ Winner: ${NAMES[ln]}!`;
        confetti();
        finished = true;
        return;
      }

      // specials
      await handleSpecial(ln);
      if(finished) return;

      if(!forceSame){
        current = (current+1)%LANE_COUNT;
        showTurn();
      }
    }

    async function onRoll(){
      if(finished) return;
      await takeTurn(current, false);
    }

    function resetGame(){
      finished = false;
      positions = new Array(LANE_COUNT).fill(0);
      skipNext = new Array(LANE_COUNT).fill(false);
      current = 0;
      status.textContent = "";
      winner.textContent = "";
      buildBoard();
    }

    // Confetti
    function confetti(){
      const emojis = ["üéâ","üéä","üèÜ","üêé"];
      let count=0;
      const timer=setInterval(()=>{
        const e=document.createElement("div");
        e.textContent=emojis[randInt(emojis.length)];
        e.style.position="fixed";
        e.style.left=Math.random()*100+"vw";
        e.style.top="-10px";
        e.style.fontSize="2.4rem";
        e.style.pointerEvents="none";
        e.style.animation="fall 2s linear forwards";
        document.body.appendChild(e);
        setTimeout(()=>e.remove(),2050);
        if(++count>48) clearInterval(timer);
      },60);
      const style=document.createElement("style");
      style.innerHTML="@keyframes fall{to{transform:translateY(100vh) rotate(360deg);opacity:.15}}";
      document.head.appendChild(style);
    }

    // Build & place
    window.addEventListener("load", resetGame);
    window.addEventListener("resize", ()=>{
      for(let ln=0; ln<LANE_COUNT; ln++) placeHorse(ln, positions[ln]);
    });
    rollBtn.addEventListener("click", onRoll);
    resetBtn.addEventListener("click", resetGame);
  </script>
</body>
</html>
