<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ğŸ Lucky Horses â€” ProjectorFirst</title>
  <meta name="description" content="Candy Landâ€“style horse race. Roll 0â€“6 (0 = Go Back Home). Specials: Jump Ahead, Go Back, Roll Again, Lose Turn."/>
  <meta name="theme-color" content="#1e3a8a"/>
  <link rel="icon" href="/logo.svg" type="image/svg+xml"/>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body{background:#fff;color:#111;font-family:ui-sans-serif,system-ui,-apple-system,sans-serif;
      display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:1.5rem;text-align:center}
    h1{font-size:3rem;font-weight:900;color:#1e3a8a;margin-bottom:.5rem}
    .sub{font-size:1.125rem;color:#374151}

    /* Board area */
    #board{width:min(96vw,1300px);margin:1.25rem auto}
    .lane{position:relative;margin:14px 0;padding:10px;border:3px solid #1e3a8a22;border-radius:14px}
    .track{display:grid;grid-auto-flow:column;grid-auto-columns:clamp(38px,3.2vw,56px);gap:6px;overflow-x:auto;padding:6px}
    .sq{height:clamp(38px,3.2vw,56px);border-radius:10px;border:2px solid #93c5fd;display:flex;align-items:center;justify-content:center;position:relative;background:#fff}
    /* Candy stripe palette for columns */
    .c0{background:#fde68a} .c1{background:#bfdbfe} .c2{background:#bbf7d0} .c3{background:#fecaca}
    .mark{position:absolute;right:4px;bottom:2px;font-size:1.05rem}
    .start{outline:3px dashed #1e3a8a;outline-offset:-6px}
    .finish{outline:3px solid #16a34a;outline-offset:-6px}

    /* Horse token */
    .horse{position:absolute;font-size:2rem;line-height:1;filter:drop-shadow(0 2px 0 rgba(0,0,0,.15))}
    .gallop{animation:gallop .18s ease-in-out infinite alternate}
    @keyframes gallop{from{transform:translateY(0)}to{transform:translateY(-5px)}}

    /* Buttons & status */
    .btn{font-size:1.6rem;font-weight:800;padding:1rem 2rem;border-radius:1rem;min-width:220px;cursor:pointer;transition:transform .08s}
    .btn:hover{transform:scale(1.04)}
    .btn-blue{background:#1e3a8a;color:#fff}
    .btn-red{background:#dc2626;color:#fff}
    #status{margin-top:.8rem;font-size:2rem;color:#1e3a8a;font-weight:800}
    #winner{margin-top:.6rem;font-size:2.2rem;font-weight:900;color:#16a34a}

    /* Legend */
    .legend{display:flex;gap:14px;justify-content:center;flex-wrap:wrap;margin-top:.6rem;color:#374151}
    .tag{display:inline-flex;align-items:center;gap:6px;border:2px solid #cbd5e1;border-radius:999px;padding:4px 10px;font-weight:700}

    /* Lane headers */
    .laneHdr{display:flex;align-items:center;gap:10px;margin:4px 0 8px 6px;font-weight:900;color:#1e3a8a}
    .pill{border-radius:999px;color:#fff;padding:2px 10px;font-weight:800}
    .p1{background:#1e3a8a}.p2{background:#dc2626}.p3{background:#16a34a}.p4{background:#7c3aed}
  </style>
</head>
<body>
  <a href="apps.html" class="text-white bg-blue-800 hover:bg-blue-900 px-6 py-3 rounded-full text-xl font-bold mb-4">â¬… Back to Apps</a>

  <h1>ğŸ Lucky Horses</h1>
  <p class="sub">Roll the dice (0â€“6). <strong>0 = Go Back Home.</strong> Land on â­ to jump ahead, ğŸ’€ to go back, ğŸ” to roll again, ğŸš« to lose next turn.</p>

  <div id="board"></div>

  <div class="flex flex-wrap gap-4 justify-center mt-5">
    <button id="rollBtn" class="btn btn-blue">ğŸ² Roll Dice</button>
    <button id="resetBtn" class="btn btn-red">ğŸ” Reset</button>
  </div>

  <div id="status"></div>
  <div id="winner"></div>

  <div class="legend">
    <span class="tag">â­ Jump +3</span>
    <span class="tag">ğŸ’€ Back âˆ’3</span>
    <span class="tag">ğŸ” Roll Again</span>
    <span class="tag">ğŸš« Lose Next Turn</span>
    <span class="tag">ğŸ Finish</span>
  </div>

  <script>
    // ====== CONFIG ======
    const HORSES = ["ğŸ","ğŸ´","ğŸ‡","ğŸ¦„"];
    const HORSE_NAMES = ["Horse 1","Horse 2","Horse 3","Horse 4"];
    const HORSE_PILLS = ["p1","p2","p3","p4"];
    const LANE_COUNT = 4;
    const TRACK_LEN = 30; // squares per lane
    const SPECIAL_COUNTS = { jump:4, back:4, again:2, skip:2 }; // per board
    const JUMP_VALUE = 3;
    const BACK_VALUE = 3;

    // ====== STATE ======
    let lanes = [];                 // per-lane track DOM containers
    let squares = [];               // shared specials per column index (0..TRACK_LEN-1)
    let horseElems = [];            // horse DOM elements (absolute within lane)
    let positions = new Array(LANE_COUNT).fill(0); // per-lane current index
    let skipNext  = new Array(LANE_COUNT).fill(false);
    let current   = 0;              // whose turn
    let finished  = false;

    const board = document.getElementById("board");
    const status = document.getElementById("status");
    const winner = document.getElementById("winner");
    const rollBtn = document.getElementById("rollBtn");
    const resetBtn = document.getElementById("resetBtn");

    // ====== UTIL ======
    function randInt(max){ return Math.floor(Math.random()*max); }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=randInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

    // Build specials array once per game (shared across lanes)
    function makeSpecials(){
      const types = [];
      for(let i=0;i<SPECIAL_COUNTS.jump;i++) types.push("jump");
      for(let i=0;i<SPECIAL_COUNTS.back;i++) types.push("back");
      for(let i=0;i<SPECIAL_COUNTS.again;i++) types.push("again");
      for(let i=0;i<SPECIAL_COUNTS.skip;i++) types.push("skip");
      const indices = shuffle([...Array(TRACK_LEN-2).keys()].map(i=>i+1)); // avoid start(0) & last(TRACK_LEN-1)
      const map = new Array(TRACK_LEN).fill(null);
      for(let k=0;k<types.length && k<indices.length;k++){
        map[indices[k]] = types[k];
      }
      map[TRACK_LEN-1] = "finish";
      return map;
    }

    // Build the whole board DOM
    function buildBoard(){
      board.innerHTML = "";
      lanes = []; horseElems = [];
      squares = makeSpecials();

      for(let ln=0; ln<LANE_COUNT; ln++){
        const lane = document.createElement("section");
        lane.className = "lane";

        const hdr = document.createElement("div");
        hdr.className = "laneHdr";
        hdr.innerHTML = `${HORSES[ln]} <span class="pill ${HORSE_PILLS[ln]}">${HORSE_NAMES[ln]}</span>`;
        lane.appendChild(hdr);

        const track = document.createElement("div");
        track.className = "track";
        lane.appendChild(track);

        // squares (shared specials by column)
        for(let i=0;i<TRACK_LEN;i++){
          const sq = document.createElement("div");
          sq.className = `sq c${i%4}`;
          if(i===0) sq.classList.add("start");
          if(i===TRACK_LEN-1) sq.classList.add("finish");

          const t = squares[i];
          if(t){
            const m = document.createElement("div");
            m.className = "mark";
            m.textContent = (t==="jump")?"â­":(t==="back")?"ğŸ’€":(t==="again")?"ğŸ”":(t==="skip")?"ğŸš«":"";
            sq.appendChild(m);
          }
          track.appendChild(sq);
        }

        // horse element positioned over the first square
        const token = document.createElement("div");
        token.className = "horse";
        token.textContent = HORSES[ln];
        lane.appendChild(token);

        board.appendChild(lane);
        lanes.push(lane);
        horseElems.push(token);
      }

      // initial placement
      for(let ln=0; ln<LANE_COUNT; ln++){
        placeHorse(ln, positions[ln]);
      }
      showTurn();
    }

    // Position horse over a given square index in its lane
    function placeHorse(ln, idx){
      const track = lanes[ln].querySelector(".track");
      const sq = track.children[Math.max(0, Math.min(idx, TRACK_LEN-1))];
      const rect = track.getBoundingClientRect();
      const srect = sq.getBoundingClientRect();
      const token = horseElems[ln];
      // translate to lane-local coordinates:
      const left = (srect.left - rect.left) + srect.width/2 - 14; // center it, token ~28px width
      const top  = (srect.top  - rect.top ) + srect.height/2 - 16;
      token.style.left = left + "px";
      token.style.top  = top  + "px";
    }

    // Animate step-by-step movement (forward or backward)
    async function stepMove(ln, steps){
      const dir = Math.sign(steps);
      const count = Math.abs(steps);
      const token = horseElems[ln];
      token.classList.add("gallop");
      for(let s=0; s<count; s++){
        positions[ln] += dir;
        if(positions[ln] < 0) positions[ln] = 0;
        if(positions[ln] > TRACK_LEN-1) positions[ln] = TRACK_LEN-1;
        placeHorse(ln, positions[ln]);
        await wait(190);
      }
      token.classList.remove("gallop");
    }

    // Dice roll 0â€“6 (0 triggers "Go Back Home")
    function rollD7(){
      // slightly fairer: crypto if available
      if(window.crypto && crypto.getRandomValues){
        const arr = new Uint32Array(1);
        crypto.getRandomValues(arr);
        return arr[0] % 7; // 0..6
      }
      return Math.floor(Math.random()*7);
    }

    function showTurn(msg){
      if(finished) return;
      const who = `${HORSES[current]} ${HORSE_NAMES[current]}`;
      status.textContent = msg || `Your turn: ${who} â€” click â€œRoll Diceâ€`;
    }

    async function handleSpecial(ln){
      const tile = squares[positions[ln]];
      if(!tile || tile==="finish") return;

      if(tile==="jump"){
        status.textContent = `â­ ${HORSE_NAMES[ln]} jumps ahead +${JUMP_VALUE}!`;
        await stepMove(ln, +JUMP_VALUE);
      } else if(tile==="back"){
        status.textContent = `ğŸ’€ ${HORSE_NAMES[ln]} goes back âˆ’${BACK_VALUE}.`;
        await stepMove(ln, -BACK_VALUE);
      } else if(tile==="again"){
        status.textContent = `ğŸ” ${HORSE_NAMES[ln]} rolls again!`;
        await wait(450);
        await takeTurn(ln, /*forceSame=*/true); // immediate extra turn
      } else if(tile==="skip"){
        status.textContent = `ğŸš« ${HORSE_NAMES[ln]} will lose next turn.`;
        skipNext[ln] = true;
      }
    }

    async function takeTurn(ln, forceSame=false){
      if(finished) return;

      // Skip turn handling
      if(skipNext[ln]){
        skipNext[ln] = false;
        status.textContent = `ğŸš« ${HORSE_NAMES[ln]} skips this turn.`;
        await wait(700);
        if(!forceSame){ current = (current+1)%LANE_COUNT; showTurn(); }
        return;
      }

      // Roll dice
      const roll = rollD7(); // 0..6
      const whoTxt = `${HORSES[ln]} ${HORSE_NAMES[ln]}`;
      if(roll===0){
        status.textContent = `ğŸ² ${whoTxt} rolled 0 â€” Go Back Home!`;
        await stepMove(ln, -positions[ln]); // back to start
      } else {
        status.textContent = `ğŸ² ${whoTxt} rolled a ${roll}.`;
        await stepMove(ln, roll);
      }

      // Win check
      if(positions[ln] >= TRACK_LEN-1){
        positions[ln] = TRACK_LEN-1;
        placeHorse(ln, positions[ln]);
        winner.textContent = `ğŸ† Winner: ${whoTxt}!`;
        confetti();
        finished = true;
        return;
      }

      // Handle special tile (may chain)
      await handleSpecial(ln);
      if(finished) return;

      // Advance turn unless we forced same (used by "again")
      if(!forceSame){
        current = (current+1)%LANE_COUNT;
        showTurn();
      }
    }

    async function onRoll(){
      if(finished) return;
      await takeTurn(current, /*forceSame=*/false);
    }

    function resetGame(){
      finished = false;
      positions = new Array(LANE_COUNT).fill(0);
      skipNext  = new Array(LANE_COUNT).fill(false);
      current = 0;
      winner.textContent = "";
      status.textContent = "";
      buildBoard();
    }

    // Simple falling emoji confetti
    function confetti(){
      const emojis = ["ğŸ‰","ğŸŠ","ğŸ†","ğŸ"];
      let count = 0;
      const timer = setInterval(()=>{
        const e = document.createElement("div");
        e.textContent = emojis[randInt(emojis.length)];
        e.style.position="fixed";
        e.style.left = Math.random()*100 + "vw";
        e.style.top  = "-10px";
        e.style.fontSize = "2rem";
        e.style.pointerEvents="none";
        e.style.animation="fall 2s linear forwards";
        document.body.appendChild(e);
        setTimeout(()=>e.remove(),2050);
        if(++count>42) clearInterval(timer);
      },60);
      const style = document.createElement("style");
      style.innerHTML = "@keyframes fall{to{transform:translateY(100vh) rotate(360deg);opacity:.1}}";
      document.head.appendChild(style);
    }

    // Build & wire
    window.addEventListener("load", resetGame);
    window.addEventListener("resize", ()=>{
      // re-place horses on resize to keep tokens centered on squares
      lanes.forEach((_,ln)=>placeHorse(ln, positions[ln]));
    });
    document.getElementById("rollBtn").addEventListener("click", onRoll);
    document.getElementById("resetBtn").addEventListener("click", resetGame);
  </script>
</body>
</html>
